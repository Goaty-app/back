<?php

namespace App\Tests\Helper;

use DateTime;
use DateTimeImmutable;

/**
 * InvalidPayloadGenerator.
 *
 * This utility class is designed to dynamically generate a comprehensive set of
 * invalid data payloads for testing entity creation endpoints. It leverages the
 * `EntityAttributeInspector` service to retrieve validation rules (e.g., NotBlank,
 * Type, Length) and ORM column details (e.g., length, nullability) defined
 * on entity properties via PHP attributes.
 *
 * For each relevant entity field, it systematically creates test cases that
 * violate these rules, such as:
 *  - Missing required fields.
 *  - Empty values for non-blank fields.
 *  - Incorrect data types.
 *  - Values модерн than maximum allowed lengths.
 *  - Values shorter than minimum required lengths.
 *  - Null values for non-nullable fields (considering both validator and DB constraints).
 *
 * The generator takes a base valid payload and modifies one field at a time to
 * produce distinct invalid scenarios, making it useful for data providers in
 * functional API tests to ensure robust error handling.
 *
 * Note: This class, along with its dependency EntityAttributeInspector, was
 * primarily generated by an AI assistant.
 */
class InvalidPayloadGenerator
{
    private EntityAttributeInspector $inspector;

    private array $fieldsToExclude = [
        'createdAt',
        'updatedAt',
        'deletedAt',
    ];

    public function __construct()
    {
        $this->inspector = new EntityAttributeInspector();
    }

    /**
     * Generates invalid data sets for creating an entity, based on inspected fields.
     */
    public function generateInvalidData(
        string $entityClassName,
        array $baseValidPayload,
        array $fieldsToConsider = [],
    ): iterable {
        $inspectedFields = $this->inspector->inspectEntityFields($entityClassName);

        if (isset($inspectedFields['error'])) {
            yield "Error inspecting class {$entityClassName}" => [
                'payload'       => [],
                'error_message' => $inspectedFields['error'],
            ];

            return;
        }

        foreach ($inspectedFields as $propertyName => $info) {
            if (!empty($fieldsToConsider) && !\in_array($propertyName, $fieldsToConsider, true)) {
                continue;
            }

            if (\in_array($propertyName, $this->fieldsToExclude, true)) {
                continue;
            }

            if (isset($info['error'])) {
                yield "Error inspecting property {$propertyName}" => [
                    'payload'       => [],
                    'error_message' => $info['error'],
                ];
                continue;
            }

            $constraints = $info['validator_constraints'] ?? [];
            $ormColumnInfo = $info['orm_column'] ?? [];
            $phpType = $info['php_type'] ?? null;

            // 1. NotBlank tests
            if ($constraints['not_blank'] ?? false) {
                $payloadMissing = $baseValidPayload;
                unset($payloadMissing[$propertyName]);
                yield "missing ({$propertyName})" => ['payload' => $payloadMissing];

                $payloadEmpty = $baseValidPayload;
                $payloadEmpty[$propertyName] = '';
                yield "empty ({$propertyName})" => ['payload' => $payloadEmpty];

                if ($phpType && str_contains($phpType, 'null')) {
                    $payloadNullNotBlank = $baseValidPayload;
                    $payloadNullNotBlank[$propertyName] = null;
                    yield "null ({$propertyName}, with NotBlank constraint)" => ['payload' => $payloadNullNotBlank];
                }
            }

            // 2. Type tests
            $expectedType = $constraints['type'] ?? ($ormColumnInfo['type'] ?? $this->simplifyPhpType($phpType));
            if ($expectedType) {
                $invalidValuesByType = $this->getInvalidValuesForType($expectedType);
                foreach ($invalidValuesByType as $invalidValueData) {
                    $invalidValue = $invalidValueData['value'];
                    $valueDesc = $invalidValueData['desc'];

                    $payloadInvalidType = $baseValidPayload;
                    $payloadInvalidType[$propertyName] = $invalidValue;
                    yield "invalid type ({$propertyName} expects {$expectedType}, got {$valueDesc})" => [
                        'payload' => $payloadInvalidType,
                    ];
                }
            }

            // 3. Max Length tests
            $maxLength = $constraints['length_max'] ?? ($ormColumnInfo['length'] ?? null);
            if ($maxLength && ('string' === $expectedType || ($constraints['type'] ?? null) === 'string')) {
                $payloadTooLong = $baseValidPayload;
                $payloadTooLong[$propertyName] = str_repeat('a', (int) $maxLength + 1);
                yield "too long ({$propertyName}, max {$maxLength})" => ['payload' => $payloadTooLong];
            }

            // 4. Min Length tests
            $minLength = $constraints['length_min'] ?? null;
            if ($minLength && $minLength > 0 && ('string' === $expectedType || ($constraints['type'] ?? null) === 'string')) {
                $payloadTooShort = $baseValidPayload;
                $tooShortValue = $minLength > 1 ? str_repeat('a', (int) $minLength - 1) : '';
                if (!('' === $tooShortValue && ($constraints['not_blank'] ?? false))) {
                    $payloadTooShort[$propertyName] = $tooShortValue;
                    yield "too short ({$propertyName}, min {$minLength})" => ['payload' => $payloadTooShort];
                }
            }

            // 5. NotNull constraint test
            if (($constraints['not_null'] ?? false) && !($constraints['not_blank'] ?? false) && $phpType && str_contains($phpType, 'null')) {
                $payloadNullWithNotNull = $baseValidPayload;
                $payloadNullWithNotNull[$propertyName] = null;
                yield "null ({$propertyName}, with NotNull constraint)" => ['payload' => $payloadNullWithNotNull];
            }

            // 6. ORM non-nullable test (if validator might pass null)
            $ormColNullable = $ormColumnInfo['nullable'] ?? true;
            $phpAllowsNull = $phpType && str_contains($phpType, 'null');

            if (!$ormColNullable && $phpAllowsNull && !($constraints['not_blank'] ?? false) && !($constraints['not_null'] ?? false)) {
                $payloadNullDbNotNullable = $baseValidPayload;
                $payloadNullDbNotNullable[$propertyName] = null;
                yield "null ({$propertyName}, validator OK but DB not nullable)" => ['payload' => $payloadNullDbNotNullable];
            }
        }
    }

    private function getInvalidValuesForType(string $expectedType): array
    {
        $commonInvalid = [
            ['value' => (object) ['prop' => 'val'], 'desc' => 'object'],
            ['value' => ['array_val'], 'desc' => 'array'],
        ];
        $invalids = [
            'string'             => array_merge([['value' => 123, 'desc' => 'integer 123'], ['value' => true, 'desc' => 'boolean true']], $commonInvalid),
            'integer'            => array_merge([['value' => 'not_an_int', 'desc' => 'string "not_an_int"'], ['value' => '123.45', 'desc' => 'string "123.45"'], ['value' => 12.34, 'desc' => 'float 12.34'], ['value' => true, 'desc' => 'boolean true']], $commonInvalid),
            'boolean'            => array_merge([['value' => 'not_a_bool', 'desc' => 'string "not_a_bool"'], ['value' => 123, 'desc' => 'integer 123'], ['value' => 0, 'desc' => 'integer 0 (not a bool)'], ['value' => 1, 'desc' => 'integer 1 (not a bool)']], $commonInvalid),
            'float'              => array_merge([['value' => 'not_a_float', 'desc' => 'string "not_a_float"'], ['value' => true, 'desc' => 'boolean true']], $commonInvalid),
            'array'              => [['value' => 'not_an_array', 'desc' => 'string "not_an_array"'], ['value' => 123, 'desc' => 'integer 123'], ['value' => (object) ['prop' => 'val'], 'desc' => 'object']],
            'datetime'           => [['value' => 'not_a_date', 'desc' => 'string "not_a_date"'], ['value' => '2023-13-01', 'desc' => 'invalid date string "2023-13-01"'], ['value' => 1234567890, 'desc' => 'timestamp integer']],
            'datetime_immutable' => [['value' => 'not_a_date_immutable', 'desc' => 'string "not_a_date_immutable"'], ['value' => '2023-02-30', 'desc' => 'invalid date string "2023-02-30"']],
        ];

        return $invalids[strtolower($expectedType)] ?? $commonInvalid;
    }

    private function simplifyPhpType(?string $phpType): ?string
    {
        if (null === $phpType) {
            return null;
        }
        $type = explode('|', $phpType)[0];

        return match ($type) {
            'int'                    => 'integer',
            'bool'                   => 'boolean',
            DateTime::class          => 'datetime',
            DateTimeImmutable::class => 'datetime_immutable',
            default                  => $type,
        };
    }
}
