<?php

namespace App\Tests\Helper;

use DateTime;
use DateTimeImmutable;
use Doctrine\ORM\Mapping as ORM;
use ReflectionClass;
use ReflectionException;
use ReflectionNamedType;
use ReflectionProperty;
use ReflectionUnionType;
use Symfony\Component\Validator\Constraints as Assert;

/**
 * EntityAttributeInspector.
 *
 * This service class utilizes PHP's Reflection API to inspect entity classes
 * and extract metadata from their property attributes. It focuses on "fields" â€“
 * properties mapped with Doctrine's ORM\Column attribute that are neither
 * identifiers (ORM\Id) nor direct ORM relations (e.g., OneToMany, ManyToOne).
 *
 * The primary goal is to gather information about:
 *  - PHP data types of properties.
 *  - Doctrine ORM\Column mapping details (type, length, nullability, uniqueness).
 *  - Symfony Validator constraints (e.g., NotBlank, NotNull, Type, Length).
 *
 * This information can then be used by other services or test utilities,
 * for instance, to dynamically generate test data or validate entity structures.
 *
 * Note: This class was primarily generated by an AI assistant.
 */
class EntityAttributeInspector
{
    /**
     * Inspects "fields" (non-ID, non-relation scalar properties) of a class.
     */
    public function inspectEntityFields(string $className): array
    {
        $fieldsInfo = [];

        try {
            if (!class_exists($className)) {
                return ['error' => "Class {$className} not found or not autoloadable."];
            }
            $reflectionClass = new ReflectionClass($className);
            $properties = $reflectionClass->getProperties();

            foreach ($properties as $reflectionProperty) {
                if ($this->isIdentifierProperty($reflectionProperty) || $this->isRelationProperty($reflectionProperty)) {
                    continue;
                }

                $propertyName = $reflectionProperty->getName();
                $propertyInfo = $this->extractFieldAttributesInfo($reflectionProperty);
                $fieldsInfo[$propertyName] = $propertyInfo;
            }
        } catch (ReflectionException $e) {
            return ['error' => "Reflection error for class {$className}: ".$e->getMessage()];
        }

        return $fieldsInfo;
    }

    private function isIdentifierProperty(ReflectionProperty $reflectionProperty): bool
    {
        return !empty($reflectionProperty->getAttributes(ORM\Id::class));
    }

    private function isRelationProperty(ReflectionProperty $reflectionProperty): bool
    {
        $relationAttributes = [
            ORM\OneToMany::class,
            ORM\ManyToOne::class,
            ORM\ManyToMany::class,
            ORM\OneToOne::class,
        ];
        foreach ($relationAttributes as $relationAttribute) {
            if (!empty($reflectionProperty->getAttributes($relationAttribute))) {
                return true;
            }
        }

        return false;
    }

    /**
     * Extracts attribute information for a "field" (scalar property).
     */
    private function extractFieldAttributesInfo(ReflectionProperty $reflectionProperty): array
    {
        $propertyName = $reflectionProperty->getName();
        $propertyInfo = [
            'php_type'   => null,
            'orm_column' => [
                'type'     => null,
                'length'   => null,
                'nullable' => null,
                'unique'   => false,
            ],
            'validator_constraints' => [
                'type'       => null,
                'not_blank'  => false,
                'not_null'   => false,
                'length_max' => null,
                'length_min' => null,
            ],
        ];

        // 1. PHP Type
        $propertyPhpType = $reflectionProperty->getType();
        if ($propertyPhpType instanceof ReflectionNamedType) {
            $propertyInfo['php_type'] = $propertyPhpType->getName().($propertyPhpType->allowsNull() && 'mixed' !== $propertyPhpType->getName() ? '|null' : '');
        } elseif ($propertyPhpType instanceof ReflectionUnionType) {
            $types = [];
            foreach ($propertyPhpType->getTypes() as $type) {
                $types[] = $type->getName();
            }
            $propertyInfo['php_type'] = implode('|', $types);
        }

        // 2. Process relevant attributes for fields
        $attributes = $reflectionProperty->getAttributes();
        $isOrmColumnExplicitlyNullable = null;

        foreach ($attributes as $reflectionAttribute) {
            $attributeName = $reflectionAttribute->getName();
            $attributeArguments = $reflectionAttribute->getArguments();

            switch ($attributeName) {
                case ORM\Column::class:
                    $propertyInfo['orm_column']['type'] = $attributeArguments['type'] ?? $this->inferDoctrineTypeFromPhpType($propertyInfo['php_type'], $propertyName);
                    $propertyInfo['orm_column']['length'] = $attributeArguments['length'] ?? null;
                    if (isset($attributeArguments['nullable'])) {
                        $propertyInfo['orm_column']['nullable'] = $attributeArguments['nullable'];
                        $isOrmColumnExplicitlyNullable = $attributeArguments['nullable'];
                    }
                    $propertyInfo['orm_column']['unique'] = $attributeArguments['unique'] ?? false;
                    break;

                    // ID and Relation attributes are filtered out before calling this method

                case Assert\NotBlank::class:
                    $propertyInfo['validator_constraints']['not_blank'] = true;
                    $propertyInfo['validator_constraints']['not_null'] = true; // NotBlank implies NotNull
                    break;
                case Assert\NotNull::class:
                    $propertyInfo['validator_constraints']['not_null'] = true;
                    break;
                case Assert\Length::class:
                    $propertyInfo['validator_constraints']['length_max'] = $attributeArguments['max'] ?? null;
                    $propertyInfo['validator_constraints']['length_min'] = $attributeArguments['min'] ?? null;
                    break;
                case Assert\Type::class:
                    $propertyInfo['validator_constraints']['type'] = $attributeArguments['type'] ?? null;
                    break;

                    // Serializer Groups are ignored as per request
            }
        }

        // Finalize ORM\Column nullability if not explicitly set
        if (null === $isOrmColumnExplicitlyNullable) {
            $propertyInfo['orm_column']['nullable'] = ($propertyInfo['php_type'] && str_contains($propertyInfo['php_type'], 'null'));
        }

        return $propertyInfo;
    }

    private function inferDoctrineTypeFromPhpType(?string $phpType, string $propertyName): ?string
    {
        if (null === $phpType) {
            return null;
        }
        $phpTypeBase = str_replace('|null', '', $phpType);

        return match ($phpTypeBase) {
            'int'                    => 'integer',
            'string'                 => 'string',
            'bool'                   => 'boolean',
            DateTime::class          => 'datetime',
            DateTimeImmutable::class => 'datetime_immutable',
            'float'                  => 'float',
            'array'                  => 'json', // Common mapping for PHP array to Doctrine JSON
            default                  => $phpTypeBase, // For other unmapped types or custom objects
        };
    }
}
